---
layout: post
title: "python中with语句的用法"
date: 2014-05-18 21:00:53 +0800
comments: true
categories: backend
description: ""
keywords: "python with cairo context manager yield"
---

with语句在python2.5中引入，可以非常方便地处理两个相关的操作，with语句块在这两个操作中间执行。其典型的应用是打开文件，操作文件，然后关闭文件。

<div>
{% codeblock lang:python %}
with open('output.txt', 'w') as f:
    f.write('Hi there!')
{% endcodeblock %}
</div>

上述with语句会在嵌套的代码执行完后自动关闭文件。当with语句块中抛出异常时，在这个异常被外层处理器捕获之前，文件会被关闭。当嵌套的with语句中执行到return，continue，break等语句时，文件也会被关闭。

下面列举另一个例子。pycairo是python的图形库。其Context类提供save()方法，用来将当前的绘图状态压入栈中，以及一个restore()方法用来从栈顶恢复前一个绘图状态。这两个函数一般成对地调用。

以下代码用一个Context对象来画六个长方形，每个长方形旋转了不同的角度。每当调用rotate时实际上结合了当前的变换。因此在循环的每一次迭代时我们用一对save和restore来保存绘图状态。这样就避免了旋转操作结合上一次旋转。

<div>
{% codeblock lang:python %}
cr.translate(68, 68)
for i in xrange(6):
    cr.save()
    cr.rotate(2 * math.pi * i / 6)
    cr.rectangle(-25, -60, 50, 40)
    cr.stroke()
    cr.restore()
{% endcodeblock %}
</div>

<div>
{% img {{ root_url }}/images/2014-5/six-rectangles.png '六个矩形' %}
</div>

这是一个非常简单的例子，但是对于大型程序来说每次跟踪哪个save和哪个restore配对是很麻烦的。with语句可以使这种代码变得简介一些。

pycairo不支持with，所以我们必须自己编程实现它。有两种办法来实现：
- 实现一个context manager类
- 写一个生成器函数

###实现一个context manager类

我们现在定义一个包含__enter__和__exit__方法的类：

<div>
{% codeblock lang:python %}
class Saved():
    """ Saved可以被认为是context manager """
    def __init__(self, cr):
        self.cr = cr
    def __enter__(self):
        self.cr.save()
        return self.cr
    def __exit__(self, type, value, traceback):
        self.cr.restore()
{% endcodeblock %}
</div>

<div>
{% codeblock lang:python %}
cr.translate(68, 68)
for i in xrange(6):
    with Saved(cr):
        cr.rotate(2 * math.pi * i / 6)
        cr.rectangle(-25, -60, 50, 40)
        cr.stroke()
{% endcodeblock %}
</div>

下面是python解释器执行with时的详细步骤：

1. with语句将Saved对象保存在临时的，隐藏的变量中用于，或赋给as之后的变量；
2. with语句调用Saved对象的__enter__方法，使context manager工作；
3. __enter__方法调用在cairo的context中调用save；
4. __enter__方法返回cairo context，但是我们还没有指定“as”变量，所以不保存返回的值；
5. 嵌套语句快执行；
6. 在嵌套语句块的结尾，with语句调用Saved对象的__exit__方法，传入(None, None, None)代表没有异常发生；
7. __exit__方法在cairo context上调用restore。

###异常处理

当with中嵌套的语句抛出异常时，比如我们传递错误的参数给rectangle方法，python解释器处理异常的步骤如下：

1. rectangle方法抛出一个TypeError异常；
2. with语句捕获这个异常；
3. with语句调用Saved对象上的__exit__方法，传递关于异常的三个参数：(type, value, traceback)--当你调用sys.exc_info时会得到相同的值。这将告诉__exit__方法所有的信息。
4. 在这种情况下，__exit__方法在cairo context上调用restore，然后返回None。（在python中，当没有return语句时总是返回None）；
5. with语句检查返回值是否是True，因为不是，所以with语句重新抛出TypeError异常，外层函数可能处理这个异常。

这样，不管一层发生与否，我们都能保证restore永远会在cairo context上被调用。

###以生成器来实现Context manager

下面是并不完整的生成器函数，因为它不能很好地处理异常：

<div>
{% codeblock lang:python %}
from contextlib import contextmanager

@contextmanager
def saved(cr):
    cr.save()
    yield cr
    cr.restore()
{% endcodeblock %}
</div>

生成器看似比之前那个方法简单一些。但是这个方法要执行更多的步骤。想要完全理解它，除了对面向对象编程要熟悉之外，还必须对python装饰器，生成器，迭代器和返回函数的函数非常熟悉。

这种方法需要contextlib库中的两个对象：

1. contextmanager函数；
2. GeneratorContextManager类。

现在我简单写一些我对contextlib.py的理解。我们从生成器开始讲起，下面是代码执行的步骤：

1. python解释器能够识别yield表达式。因此def不是声明一个通常的函数，而是创建了一个生成器函数；
2. 因为def有@contextmanager装饰器，所以contextmanager以生成器函数为参数被调用；
3. contextmanager函数返回一个工厂函数。这个工厂函数创建一个GeneratorContextManager对象；
4. 最后工厂函数被赋给saved。从此开始我们每次调用saved其实是调用这个工厂函数。

现在我们可以这样调用saved：

<div>
{% codeblock lang:python %}
for i in xrange(6):
    with saved(cr):
        cr.rotate(2 * math.pi * i / 6)
        cr.rectangle(-25, -60, 50, 40)
        cr.stroke()
{% endcodeblock %}
</div>

当python解释器遇到with语句时，执行步骤如下：

1. with语句调用saved，当然saved又调用工厂函数，传入一个cairo context--cr作为唯一参数；
2. 工厂函数把cairo context传入生成器函数，创建一个生成器generator；
3. generator被传入GeneratorContextManager；
4. with语句将GeneratorContextManager保存在一个临时的，隐藏的变量中（事实上with只保存__exit__方法）；
5. with语句在GeneratorContextManager对象上调用__exit__；
6. __enter__在generator上调用next；
7. 生成器函数（在def saved(cr)下面的代码块）运行直到yield表达式。这在cairo context上调用save；
8. yield表达式产生cairo context，cairo context变成在迭代器上调用next的返回值；
9. __enter__方法返回cairo context，但是我们没有声明“as”，所以cairo context没有被保存下来；
10. 嵌套的代码块被执行。这将设置旋转以及画一个矩形；
11. 在嵌套的代码块的底部，with语句在GeneratorContextManager上调用__exit__方法；
12. __exit__方法在迭代器上调用next(期待一个StopIterration异常发生);
13. 生成器在yield之后恢复执行，这在cairo context上调用restore；
14. 生成器返回，抛出一个StopIteration异常（就像期待的一样）;
15. __exit__捕获这个异常，正常返回。

这样我们就成功地将这个生成器函数当成with语句的context manager。为了正确地处理异常，我们还需要改善一下生成器函数。

###处理异常

现在我们还是假设把错误的参数传入rectangle函数，下面是出现的情况：

1. rectangle函数抛出一个TypeError异常；
2. with语句捕获这个异常；
3. with语句在GeneratorContextManager对象上调用__exit__，把关于异常的信息(type, value, traceback)传入；
4. __exit__在迭代器上调用throw，传入相同的三个参数；
5. TypeError异常在生成器函数的上下文中被抛出，在yield表达式那一行。

现在的生成器函数还有一个问题;restore不会在cairo context上被调用。因为yield表达式抛出一个异常，所以剩下的语句不会被执行。我们必须在yield周围加入一个try／finally块让生成器函数更加健壮：

<div>
{% codeblock lang:python %}
@contextmanager
def saved(cr):
    cr.save()
    try:
        yield cr
    finally:
        cr.restore()
{% endcodeblock %}
</div>

1. 在生成器中，finally块执行。这会在cairo context上调用restore；
2. TypeError不被生成器处理，所以它在__exit__方法中重新被抛出；
3. __exit__捕获TypeError；
4. __exit__得知捕获的异常和传入的异常是一样的，结果返回None；
5. with语句检查返回值是否是真，因为不是，所以重新抛出TypeError异常，现在这个异常将在外层代码中被捕获。

###总结

如果你像我一样很难完全理解with语句--尤其你对生成器感兴趣--不要灰心。这非常复杂，掺杂了python语言的很多特性，一些特性还是刚刚加入到python标准。




























